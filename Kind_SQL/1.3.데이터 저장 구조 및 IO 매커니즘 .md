# 1.3 데이터 저장 구조 및 IO 매커니즘

## 1.3.1 SQL이 느린 이유

- SQL이 느린 이유는 십중팔구 IO 때문이다.  구체적으로 디스크 IO 때문이다.
- IO는 OS 또는 IO 서브시스템이 IO를 처리하는 동안 프로세스는 대기한다.
- 프로세스는 실행 중인 프로그램이다.
- 프로세스의 생명주기는 생성(new) 이후 종료(terminated) 전까지 준비(ready)와 실행(running)과 대기(waiting) 상태를 반복한다. 실행 중인 프로세스는 interrupt에 의해 수시로 실행 준비 상태(Runnable Queue)로 전환했다가 다시 실행 상태로 전환한다. 여러 프로세스가 하나의 CPU를 공유할 수 있지만 특정 순간에는 하나의 프로세스만 CPU를 점유할 수 있기 때문에 이런 매커니즘이 필요하다.

![Untitled](Untitled%202.png)

- Interrupt 없이 열심히 일하던 프로세스도 디스크에서 데이터를 읽어야할 때 CPU를 OS에 반환하고 잠시 수면(waiting) 상태에서 I/O가 완료되기를 기다린다. 정해진 OS 함수를 호출(I/O CALL)하고 CPU를 반환한 채 알람을 설정하고 대기 뷰(Wait Queue)에서 잠을 자는 것이다. 열심히 일해야할 프로세스가 한가하게 잠을 자고 있으니 IO가 많으면 성능이 느릴 수 밖에 없다.
- 디스크IO가 SQL 성능을 좌우한다고 해도 과언이 아니다.

### 1.3.2 데이터베이스 저장 구조

![Untitled](Untitled%203.png)

- 테이블스페이스, 세그먼트, 익스텐트, 블록간의 관계
    - 데이터를 저장하려면 먼저 테이블스페이스를 생성해야한다.
    - 테이블스페이스는 세그먼트를 담는 콘테이너로서 여러 개의 데이터 파일(디스크 상의 물리적인 OS파일)로 구성된다.
    - 세그먼트는 테이블, 인덱스 처럼 데이터 저장공간이 필요한 오브젝트이다.
    - 세그먼트는 여러 익스텐트로 구성된다.
    - 파티션 구조가 아니라면 테이블도 인덱스도 하나의 세그먼트이다.
    - 파티션 구조라면 각 파티션이 하나의 세그먼트가 된다.
    - LOB 컬럼은 그 자체가 하나의 세그먼트를 구성하므로 자신이 속한 테이블과 다른 별도 공간에 값을 저장한다.
    - 익스텐트는 공간을 확장하는 단위이다.
    - 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블 스페이스로부터 익스텐트를 추가로 할당받는다.
    - 익스텐트는 연속된 데이터 블록들의 집합이기도 하다.
- 테이블스페이스, 세그먼트, 익스텐트, 블록과 데이터 파일간의 관계
    - 세그먼트의 익스텐트들을 서로 다른 데이터 파일의 위치할 가능성이 높다.
    - 테이블스페이스르를 여러 데이터 파일로 구성하면 파일 경합을 줄이기 위해 DBMS가 데이터를 가능한 여러 데이터파일로 분산해서 저장하기 때문이다.
    
     
    
    ![Untitled](Untitled%204.png)
    
    - 익스텐트 내 블록은 서로 인접한 연속된 공간이다.
    - 익스텐트간은 연속된 데이터 파일에 존재하지 안흔다.
- DBA
    - 모든 데이터블록은 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지를 나타내는 자신만의 고유한 주소값을 갖는다. 이 주소값을 DBA(Data Block Address)라고 부른다.
- 블록 : 데이터를 읽고 쓰는 단위
- 익스텐트 : 공간을 확장하는 단위, 연속된 블록 집합
- 세그먼트 : 데이터 저장공간이 필요한 오브젝트, 테이블, 인덱스, 파티션, LOB
- 테이블스페이스 : 세그먼트를 담는 콘테이너
- 데이터파일 : 디스크 상의 물리적인 OS파일

![Untitled](Untitled%205.png)

### 1.3.3 블록 단위 IO

- DBMS가 데이터를 읽고 쓰는 단위는 블록이다.
- 특정 레코드 하나를 읽고 싶어도 해당 블록을 통째로 읽는다.
- 오라클은 기본적으로 8KB 크기의 블록을 사용하므로 1Byte를 읽기 위해 8KB를 읽는 셈이다.

```
SQL > show parameter block_size
---
NAME TYPE VALUE
db_block  integer  8192
```

- 아래와 같이 V$PARAMETER 뷰를 직접 조회할 수도 있다.

```
select value from v$parameter where name = 'db_block_size';
---
VALUE
8192
```

![Untitled](Untitled%206.png)

### 1.3.4 시퀀셜 액세스 vs 랜덤 액세스

- 데이터 블록을 액세스하는 방식으로는 시퀀셜 액세스와 랜덤 액세스 두가지가 있다.
- 시퀸셜 액세스
    - 시퀀셜 액세스는 논리적 또는 물리적 연결된 순서에 따라 차례대로 블록을 읽는 방식이다.
    - 인덱스 리프 블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 서로 연결돼 있다.
    - 오라클은 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵(map)으로 관리한다. 익스텐트 맵은 각 익스텐트의 첫 번째 블록 주소 값을 갖는다.
    - 읽어야할 익스텐트 목록을 익스텐트 맵에서 얻고 각 인스텐트의 첫번째 블록 뒤에 연속해서 저장된 블록을 순서대로 읽으면 그것이 바로 Full Table Scan이다.
- 랜덤 액세스
    - 논리적 물리적 순서를 따르지 않고 레코드 하나를 읽기 위해 한 블록씨 접근하는 방식이다.

![Untitled](Untitled.jpeg)

- 그림 우측 상단에서 인덱스를 스캔하는 굵은 실선 화살표가 시퀀셜 액세스이다.
    - (PK인덱스로 정렬되어 있는 데이터 범위를 탐색하기 위해 시퀀셜 액세스가 사용될거라 예상)
- 그림 점선 화살표가 랜덤 액세스이다.
    - (대상 데이터 범위까지 접근 후 정렬되어 있지 않은 데이터를 FULL SCAN하는 과정(?))

### 1.3.5 논리적 IO vs 물리적 IO

- 디스크 IO가 SQL 성능을 결정한다.

![Untitled](Untitled%207.png)

- ‘라이브러리 캐시’가 SQL과 실행계획, DB저장형 함수/프로시저 등을 캐싱하는 ‘코드 캐시’라고 한다면 DB버퍼캐시는 ‘데이터 캐시’라고 할 수 있다.
- 디스크에서 어렵게 읽는 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 반복적인 IO CALL을 줄이는데 목적이 있다.

![Untitled](Untitled%208.png)

- 서버 프로세스와 데이터 파일 사이에 버퍼캐시가 있으므로 데이터 블록을 읽을 땐 항상 버퍼캐시부터 탐색한다. 캐시에서 블록을 찾는다면 프로세스가 IO CALL 상태에 머무르지 않아도된다.  빠르고, 블록을 찾지 못하더라도 두번째 읽을 때부터는 IO CALL 상태가 되지 않으니 효율적이다.
- 버퍼캐시는 공유메모리 영역이므로 같은 블록을 읽는 다른 프로세스도 득을 본다.
- 버퍼 캐시를 확인하는 방법

```
SQL > show sga
Total System Global Area 3390558208 bytes
Fixed Size 2180464 bytes
Vaiable Size 1996491408 bytes
Database Buffers 1375731712 bytes
Redo Buffers 16154624 bytes
```

### 논리적IO vs 물리적IO

- 논리적 블록 IO는 SQL을 처리하는 과정에 발생한 총 블록 IO를 말한다. 일반적으로 메모리상의 버퍼 캐시를 경유하므로 메모리 IO가 논리적 IO라고 생각해도 무방하다.
- 물리적 블록 IO는 디스크에서 발생한 총 블록 IO를 말한다. 일반적으로 버퍼 캐시에서 찾지 못할 때만 디스크를 액세스하므로 논리적 블록 IO중에 일부를 물리적으로 IO한다.

### 왜 논리적 IO인가?

- 26인치 바퀴를 가진 자전거로 15km 거리 여의도까지 가려면 바퀴 7500번 가량 회전해야 한다. 이는 논리적인 일량이다.
    - 7500번 회전하는것이 총량 논리적 IO, 7500번을 어떻게 회전할지 물리적 IO
- 가속에 따라 페달 한 번 밟을 때 평균 10번 회전한다고 가정하면, 750번 가량 바퀴를 밟아야 7500회전한다. 이는 물리적인 일량이다.
- 논리적 일량은 항상 같지만 물리적 일량은 같은 길로 가도 순풍, 역풍, 도로 기울기와 상태에 따라 매번 다르다.
- SQL을 수행하면서 읽은 총 블록 IO가 논리적 IO이다. 논리적IO와 메모리IO는 같은 개념은 아니지만 결과적으로 수치는 같다.
- DB 버퍼캐시에서 블록을 찾지 못해 디스크에서 읽은 블록 IO가 물리적 IO다. 데이터가 변경되지 않아도 물리적 IO는 실행할 때 마다 다르다.

### 버퍼캐시 히트율

- 버퍼캐시 효율을 측정하는데 가장 많이 사용해 온 지표는 버퍼캐시 히트율(Buffer Cache Hit Ratio, BCHR)이다.

```
BCHR = ( 캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수 ) X 100
     = ( ( 논리적 IO - 물리적 IO ) / 논리적 IO) * 100
     = ( 1 - ( 물리적 IO / 논리적 IO ) ) * 100
```

- 애플리케이션 특성에 따라 다르지만 온라인 트랜잭션을 주로 처리하는 애플리케이션이라면 시스템 레벨에서 평균 99% 히트율을 달성해야 한다. 핵심 트랜잭션이 시스템 전체 부하의 대부분을 차지하므로 열심히 튜닝하면 99%는 달성하기 어려운 수치는 아니다.

```
물리적 IO = 논리적 IO * ( 100% - BCHR )
```

- 논리적 IO는 고정값이므로 물리적 IO는 BCHR에 의해 결정된다. BCHR은 시스템 상황에 따라 달라지므로 물리적 IO는 결국 시스템 상황에 의해 결정되는 통제 불가능한 유일한 외생변수다.
- SQL 성능을 높이기 위해서 할 수 있는 일은 논리적 IO를 줄이는 일뿐이다.
- 논리적 IO는 어떻게 줄일 수 있을까? SQL을 튜닝해서 읽는 총 블록 개수를 줄이면된다.
- 논리적 IO는 항상 일저하게 발생하지만 SQL 튜닝을 통해 줄일 수 있는 통제 가능한 내생변수다.
- 논리적 IO를 줄임으로써 물리적 IO를 줄이는 것이 곧 SQL 튜닝이다.
- 자전거로 목적지까지 빨리 이동하려면 더 가까운 길을 선택하면 된다. 풍량, 도로 기울기는 통제 불가능한 외생변수다.
- BCHR 공식을 이루는 물리적 IO는 통제 불가능한 외생변수다. 메모리 DB 버퍼캐시 크기를 늘리는 늘리는 방법 외에) 이것을 직접 줄일 방법은 없다. 하지만 논리적 IO는 통제 가능한 내생변수다. SQL을 튜닝해서 논리적 IO를 줄이면 물리적 IO도 줄고 그만큼 성능도 향상된다.

![Untitled](Untitled%209.png)

- SQL 트레이스를 통해 수집한 CALL 통계 정보다. Query와 Current 항목을 더한 값이 논리적 IO, 즉  SQL 수행과정에 읽은 (일반적으로 버퍼캐시에서 읽은) 총 블록 개수다. Disk 항목은 디스크 항목에서 물리적으로 읽은 블록 개수다. 트레이스 결과 디스크에서 601,458개 버퍼캐시에서 1,364,044개 블록을 읽었으므로 논리적 IO는 총 1,965,502개라고 잘못해석 할 수 있다.
- 블록을 읽을 때는 해당 블록을 먼저 버퍼 캐시에서 찾아보고 없을 때만 디스크에서 읽는다. 이때도 디스크에서 곧바로 읽는 게 아니라 먼저 버퍼캐시에 적재하고서 읽는다. 따라서 DB 버퍼캐시에서 읽은 1,364,944개 블록에는 디스크에서 읽은 601,458개 블록이 이미 포함돼있다.
- SQL 수행 과정에 총 1,364,044개 블록을 읽었고 그 중 601,458개를 디스크에서 읽었으므로 BCHR은 다음과 같다.

```
BCHR = ( 1 - Disk / (Query + Current))) * 100
     = ( 1 - ( 601,458 / 1,351,677 + 12,367))) * 100
     = 55.9%
```

- BCHR에는 주의해야 할 함정이 있다. BCHR이 SQL 성능을 좌우하지만 BCHR이 높다고 해서 효율적인 SQL을 의미하지 않는다는 사실이다. 같은 블록을 비효율적으로 반복해서 읽으면 BCHR이 높아진다.
- 2~4장에서 인덱스와 NL조인을 학습하고 나면 같은 블록을 반복해서 읽는 비효율이 무엇인지 이해하게 된다.

### 1.3.6 Single Block IO vs Multiblock IO

- 메모리 캐시에 모든 데이터를 담을 수 있으면 좋지만 비용적인 한계, 기술적인 한계 떄문에 일부반 캐시에 적재한다. 캐시에서 찾지 못한 데이터 블록은 IO Call을 통해 디스크에서 DB 버퍼캐시로 적재하고서 읽는다.
- IO Call 할 때 한번에 한 블록씩 요청하기도 하고 여러 블록씩 요청하기도 한다.
- 한번데 한 블록씩 요청해서 메모리에 적재하는 방식을 Single Block IO라 하고 한번에 여러 블록씨 요청해서 메모리에 적재하는 방식을 Multi Block IO라고 한다.(익스텐스는 연속된 블록의 집합)
- 인덱스를 이용할 때는 기본적으로 인덱스와 테이블 블록 모두 Single Block IO 방식을 사용한다.
- 인덱스는 소량 데이터를 읽을 때 주로 사용하므로 이 방식이 효율적이다.
- 구체적으로 아래 목록이 Single Block IO 대상 오퍼레이션이다.
    - 인덱스 루트 블록을 읽을 때
    - 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
    - 인덱스 브랜치 블록에서 얻은 주소정보로 리프 블록을 읽을 때
    - 인데스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
- 많은 데이터 블록을 읽을 때 Multiblock IO 방식이 효율적이다. 그래서 인덱스를 이용하지 않고 테이블 전체를 스캔할 때 이 방식을 사용한다.
- 이유는 다른 데 있지 않다. 프로세스가 잠자는 IO CALL 횟수를 줄여주는데 있다.
- DBMS에서 읽고자 하는 블록을 DB 버퍼캐시에서 찾지 못하면 해당 블록을 디스크에서 읽기 위해 IO Call을 한다. 그동안 프로세스는 대기 큐(Wait Queue)에서 잠을 잔다. 대용량 테이블이면 수많은 블록을 디스크에서 읽는 동안 여러 차례 잘 텐데 기왕 잠을 자려면 한꺼버에 많은 양을 요청해야 잠자는 횟수를 줄이고 성능을 높일 수 있다. 대용량 테이블을 Full Scan 할 때 Multiblock IO 단위를 크게 설정하면 성능이 좋아지는 이유다.
- 정리하면 Multiblock IO는 캐시에서 찾지 못한 특정 블록을 읽으려고 IO Call 할 때 디스크 상에 그 블록한 인정한 블록들을 한꺼번에 읽어 캐시에 미리 적재하는 기능이다.
- DBMS 블록 사이즈가 얼마건 간에 OS 단에서는 보통 1MB 단위로 IO를 수행한다. 이는 db_file_multiblock_read_count 파라미터로 확인할 수 있다.

```
SQL> show parameter db_file_multiblock_read_count
NAME TYPE VALUE
---------------------------------------------------------------------------------
db_file_multiblock_read_count / integer / 16

SQL> alter session set db_file_multiblock_read_count = 128'

세션이 변경되었습니다.
```

- 일반적으로 OS 레벨 IO 단위가 1MB, 오라클 레벨 IO 단위가 8KB이므로 이 파라미터를 128로 설정하면 담을 수 있는 만큼 최대한 담게 된다.(8KB * 128 = 1MB)
- 오라클 레벨에서 그렇게 설정할 수는 있지만 OS는 자신의 IO 단위만큼씩 읽으므로 소용없다.
- 인접한 블록이라는 것은 같은 익스텐트에 속한 블록을 의미한다.

### Multiblock IO 중간에 왜 Single Block IO가 나타나는가?

- 익스텐트 맵은 테이블 블록에 대한 인덱스
- Multiblock IO는 배치(Batch IO)라고 생각한다.
- Multiblock IO 단위는 4라고 가정하자. 익스텐트 맵을 통해 첫 번째 익스텐트에서 읽어야할 블록 목록을 확인하니 1,2,3,4,5,6,7,8,9,10이었고 그중 1번, 6번, 8번 블록이 현재 버퍼캐시에 캐싱 돼 있다고 가정하자.
    - 1번을 캐시버퍼 체인에서 찾았다. 1번 버퍼블록을 캐시에서 바로 읽는다.
    - 2번을 캐시버퍼 체인에서 못찾았다. 디스크 IO를 보류한다.
    - 3번을 캐시버퍼 체인에서 못찾았다. 디스크 IO를 보류한다.
    - 4번을 캐시버퍼 체인에서 못찾았다. 디스크 IO를 보류한다.
    - 5번을 캐시버퍼 체인에서 못찾았다. 2~5번 블록을 위해 Multiblock IO 방식으로 디스크를 IO CALL 한다. 2~5
    - 6번을 캐시버퍼 체인에서 찾았다. 6번 버퍼블록을 캐시에서 바로 읽는다.
    - 7번을 캐시버퍼 체인에서

---

### 1.3.7 Table Full Scan vs Index Range Scan

- 테이블에 저장된 데이터를 읽는 방식은 두가지다. 테이블 전체를 스캔해서 읽는 방식과 인덱스를 이용해서 읽는 방식이다.
- 전자를 Table Full Scan, 후자를 Index Range Scan라고 부른다.
- Table Full SCan은 말 그대로 테이블에 속한 블록 ‘전체;를 읽어서 사용자가 원하는 데이터를 찾는 방식이다.
- Index Range Scan는

- 테이블에 저장된 데이터를 읽는 방식은 두가지다. 테이블 전체를 스캔해서 읽는 방식을 Table Full Scan이라고 말하고 인덱스를 이용한 테이블 액세스하는 방식을 Index Range Scan이라고 부른다.
- Table Full Scan은 테이블에 속한 블록 전체를 읽어서 데이터를 찾는 방식이다.
- Index Range Scan은 인덱스에서 일정량을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾아가는 방식이다.
- Table FUll Scan은 피해야 한다는 개발자의 인식과 달리 인덱스가 SQL 성능을 떨어뜨리는 경우가 상당히 많기 때문이다.
- Table Full Scan은 시퀀셜 액세스와 Multiblock IO 방식으로 디스크 블록을 읽는다. 한 블록에 속한 모든 레코드를 한 번에 읽어 들이고 캐시에서 못 찾으면 IO Call을 통해 인접한 수십~수백개의 블록을 한꺼번에 IO하는 매커니즘이다. 이 방식을 사용하는 SQL은 스토리지 스캔 성능이 좋아지는 만큼 성능도 좋아진다.
- 소량 데이터를 찾을 때 이 방식은 비효율적이다. 큰 테이블에서 소량 데이터를 검색할 때는 반드시 인덱스를 이용해야 한다.
- Index RAnge Scan을 통한 테이블 액세스는 랜덤 액세스와 Single Block IO 방식으로 디스크 블록을 읽는다. 캐시에서 못 찾으면 레코드 하나를 읽기 위해 매번 잠을 자는 IO 매커니즘이다. 따라서 많은 데이터를 읽을 때는 불리하다. 이 방식을 사용하는 SQL은 스토리지 스캔 성능이 수십배 성능이 좋아져도 성능이 조금 밖에 좋아지지지 않는다.
- (이 기준은 IO CALL이 얼마나 일어나느냐겠다.)
- 나중에 다시 이어서 한번더한다.